Odoo language notation:

atributos de campos genéricos:
help - permite descrever a utilidade do campo;
required - torna o campo como requisito de ter uma resposta para que o objeto seja criado;
invisible - o campo fica invisível para o usuário;
readonly - o campo fica apenas para visualização;
default - valores inseridos dentro desse atributo se tornarão o padrão do campo;

Fields:

char:
definition - permite colocar palavras como resultado de um campo;
specifics attibutes:
size: delimita a quantidade de caracteres que o campo irá possuir;
trim: permite que o campo tenha ou não espaços.

boolean:
definition - permite colocar valores lógicos no campo.
specifics attibutes - nenhum.

float:
definition - permite colocar valores flutuantes no campo.
specifics attibutes:
digits: define quais vão ser os digitos decimais e o total.

integer:
definition - permite atribuir valores inteiros para o campo.
specifics attibutes: nenhum.

text:
definition - permite colocar palavras como resultado de um campo, porém com uma capacidade maior;
specifics attibutes:
trim: permite que o campo tenha ou não espaços.

datetime:
definition - permite colocar um campo com data e hora;
specifics attibutes:

date:
definition - permite colocar um campo com data;
specifics attibutes:

selection:
definition - permite colocar um campo com key e value;
specifics attibutes:

binary:
definition - permite colocar como arquivo ou imagens;
specifics attibutes: na view, o atributo filename.

image:
definition - permite colocar um campo com imagem;
specifics attibutes: 
max_width e max_height;
verify_resolution.

hmtl:
definition - permite colocar um com texto, porém outras ferramentas;
specifics attibutes:

Many2one:
definition - permite criar uma foreign key de outro model;
specifics attibutes:







ORM METHODS:



BROWSE()

se id único:
self.env("model_name").browse(1)

se lista de ids
self.env("model_name").browse([1,2,3])
console:
objects ([1,2,3])

stud_obj = self.env("model_name")
for stud in stud_obj.browse([1,2,3]):
	stud
console: 
object(1,)
object(2,)
object(3,)

stud_obj = self.env("model_name")
for stud in stud_obj.browse([1,2,3,4]):
	if stud.exists():
		stud
	else:
		print(stud,"Not Found")
console: 
stud(1,)
stud(2,)
stud(3,)
stud(4,) Not Found

Dessa forma nós possuimos acesso a um ou múltiplos objetos.




SEARCH()

Nos permite utilizar operações de banco de dados no back end.




SEARCH_COUNT()

first example:

stud_obj = self.env("student_school")
stud_obj.search_count([])

it will returns all the active records.

second example:

stud_obj = self.env("student_school")
stud_obj.search_count([('active','=',False)])

it will returns all the inactive records.




READ()

it will read the list or the single record that you are aiming.

example:

stud_obj = self.env("student_school")
stud_list = stud_obj.search([])
console: 1,2,3,4,5,6
stud_list.read([]) or stud_list.read(['id','name','bdate'])
it will returns a json data related to the previous instruction.




EXISTS()

it will verify if exists the passed record.

example:

stud_obj = self.env("student_school")
stud_list = stud_obj.browse([1,2,3,4,5])
for stud in stud_list:
	if stud.exists():
		stud.id
		stud.name
	else:
		print(stud,"Not Found")



		
ENSURE_ONE()

def method(self):
	self.ensure_one()

ensures that only have one record.

stud_obj = self.env("student_school")
stud_list = stud_obj.search([])
stud_list.method()
console: error, expected singleton.

for stud in stud_list: 
	stud.method()

console: ok.




GET_METADATA()

show us the record metadata, similar to read() function, but it gives xml_id information.



FIELDS_GET()

it will gives us a dictionary related to object fields.



FIELDS_VIEW_GET()

you can add some labels in form trought model.



NAME_GET()

it let us to change the record name that is displayed in many2one field.



_NAME_SEARCH()

